generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  password      String?   // Hashed password for Credentials provider
  role          String    @default("USER") // "USER" | "ADMIN"
  accounts      Account[]
  sessions      Session[]
  
  // Relations
  favoriteIds   String    @default("") // Comma separated IDs (SQLite workaround for array)
  // Logic: We will parse this string in the app logic or use a link table if preferred.
  // Given "simple array of IDs", and sqlite limitation on scalar arrays, let's use a mapping table or just Json/String.
  // For SQLite, standard approach for many-to-many is implicit or explicit.
  // "favoriteQuoteIds (Array of Quote IDs)" requested. 
  // Let's us a simple implicit many-to-many relation "favorites"
  favorites     Quote[]   @relation("UserFavorites")
  
  suggestedQuotes Quote[] @relation("UserSuggestions")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?
  access_token       String?
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Quote {
  id          Int      @id @default(autoincrement()) // Matching existing ID type if numbers (from JSON)
  // Actually JSON IDs were "1", "2". Int works.
  
  text        String
  author      String
  sourceTitle String?
  sourceType  String?
  topicIds    String   // Storing "1.1, 1.2" as string
  isPinned    Boolean  @default(false) // Global pin vs User pin? 
  // Requirement: "Refactor the Pin icon... toggling update user's favoriteQuoteIds" 
  // So `isPinned` in JSON might have been global, but here we want user favorites.
  // We can keep `isPinned` for "Featured" quotes if needed, or deprecate.
  
  status      String   @default("PUBLISHED") // "PENDING" | "PUBLISHED" | "REJECTED"
  // Note: JSON data is "PUBLISHED"
  
  suggestedByUserId String?
  suggestedBy       User?   @relation("UserSuggestions", fields: [suggestedByUserId], references: [id])
  
  favoritedBy       User[]  @relation("UserFavorites")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
